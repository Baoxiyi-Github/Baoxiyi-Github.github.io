3.8　readv()和writev()函数
2012-12-19 15:15:27     我来说两句  收藏    我要投稿    
本文所属图书 > UNIX/Linux程序设计教程
本书遵循最新的统一UNIX规范版本4，以Linux为平台，系统地讲述了UNIX API各种函数的编程方法。本书内容包括UNIX的发展历程与标准、标准I/O和低级I/O、文件与目录操作、进程环境与进程控制、信号处理、时间与定时...  立即去当当网订购
read()和write()系统调用每次在文件和进程的地址空间之间传送一块连续的数据。但是，应用有时也需要将分散在内存多处地方的数据连续写到文件中，或者反之。在这种情况下，如果要从文件中读一片连续的数据至进程的不同区域，使用read()则要么一次将它们读至一个较大的缓冲区中，然后将它们分成若干部分复制到不同的区域，要么调用read()若干次分批将它们读至不同区域。同样，如果想将程序中不同区域的数据块连续地写至文件，也必须进行类似的处理。

UNIX提供了另外两个函数—readv()和writev()，它们只需一次系统调用就可以实现在文件和进程的多个缓冲区之间传送数据，免除了多次系统调用或复制数据的开销。readv()称为散布读，即将文件中若干连续的数据块读入内存分散的缓冲区中。writev()称为聚集写，即收集内存中分散的若干缓冲区中的数据写至文件的连续区域中。
#include <sys/uio.h>
ssize_t readv(int fildes, const struct iovec *iov, int iovcnt);
ssize_t writev(int fildes, const struct iovec *iov, int iovcnt);

参数fildes是文件描述字。iov是一个结构数组，它的每个元素指明存储器中的一个缓冲区。结构类型iovec有下述成员，分别给出缓冲区的起始地址和字节数：
struct iovec {
    void   *iov_base   /* 数据区的起始地址 */
    size_t  iov_len     /* 数据区的大小 */
}

参数iovcnt指出数组iov的元素个数，元素个数至多不超过IOV_MAX。Linux中定义IOV_MAX的值为1024。

图3-4说明了参数iovcnt、iov及其所指数组与这两个函数的关系。writev()依次将iov[0]、iov[1]、...、 iov[iovcnt–1]指定的存储区中的数据写至fildes指定的文件。writev()的返回值是写出的数据总字节数，正常情况下它应当等于所有数据块长度之和。
<a herf = http://www.2cto.com/uploadfile/2012/1219/20121219031549963.jpg>图3-4</a>

 
readv()则将fildes指定文件中的数据按iov[0]、iov[1]、...、iov[iovcnt–1]规定的顺序和长度，分散地读到它们指定的存储地址中。readv()的返回值是读入的总字节数。如果没有数据可读和遇到了文件尾，其返回值为0。

有了这两个函数，当想要集中写出某张链表时，只需让iov数组的各个元素包含链表中各个表项的地址和其长度，然后将iov和它的元素个数作为参数传递给writev()，这些数据便可一次写出。
